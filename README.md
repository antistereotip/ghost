## RIP Danilo Bogdanov.
https://usk.rs/matematika/ 
### Ghost Protocol. First invisible protocol in history of network.
https://usk.rs/ghost/ 
### Ng1np. Legal Open Source Array Engine.
https://usk.rs/ng1np/ 
#### Coding name: Ghost 1337 :: Login or Die :: Antistereotip :: Operation Apostols

<img src="http://ForTheBadge.com/images/badges/built-with-love.svg" /><br />
<img src="https://img.shields.io/badge/C-00599C?style=for-the-badge&logo=c&logoColor=white"/><img src="https://img.shields.io/badge/Shell_Script-121011?style=for-the-badge&logo=gnu-bash&logoColor=white" /><img src="https://img.shields.io/badge/Tails%20-56347C?&style=for-the-badge&logo=tails&logoColor=white" />

##### üì± Encrypted e-mail: threewhiterabbits@protonmail.com

<img src="https://github.com/antistereotip/ghost/blob/main/DATA/Ghost.png" width="400" />

## Start Of Life Ghost Protocol. 

*Ghost protocol.* 
*Ghost will start at 31.08.2025 at 13:37 PM. RIP Danilo Bogdanov.*
*The first invisible protocol in the history of the Internet.*
*Idea is also to make Ghost Programming Language Feature for Protocol (null.gpfs).*
*Fasten your seat belt, let's take off...*

## We will rule the world.

<img src="https://github.com/antistereotip/ghost/blob/main/SOCIETY/uspeh.jpg" width="600"/>

## Ghost Documentation.
### Please read all REDME.md files (Documentation links on bottom of document).
- Primary Documantation (README.md - 0)
- All Documantation (README.md - 1)
- GATES - Logic Gates, Self and Combined (README.md - 2)
- RUN - Execute Ghost Logic (README.md - 3)
- SOCIETY - Community Logic (README.md - 4)
- Folder ZERO-SQUAD - Executive Team (README.md - 5)
- Logic_Gates (NOR, XOR, NAND) - Key Map Logic
- NOR (0011-0101=1000)
- XOR (0011-0101=0110)
- NAND (0011-0101=1110)
- NAND-NOR (1110 1000)
- NAND-XOR (1110 0110)
- XOR-NOR (0110 1000)
- NAND-NOR-XOR (1110 1000 0110)
- 4, 8, 12, 16, 20, 24, 28, 32 - Bit Map Logic
- Folder 4 - One Nibble Value
- Folder 8 - Two Nibbles Value
- Folder 12 - Three Nibbles Value
- Folder 16 - Four Nibbles Value
- Folder 20 - Five Nibbles Value
- Folder 24 - Six Nibbles Value
- Folder 26 - Seven Nibbles Value
- Folder 32 - Eight Nibbles Value
- Folder 0 - 0 Nibbles Value (README.md - 6)
                                                                                          


## Develop Functions and Procedures.
TODO:
- Functions to parse nibbles
- Functions to generate combination of nibble and logic gate
- Functions for operations of bit
- Functions to randomize mixed logic
- Functions to separate nibble folders
- Functions to generate universal map key
- Function to encrypt
- Function to decrypt
- Functions for playing with pointers
- Functions for socket
- Functions for TCP/IP logic
- Functions for API logic
- Functions for including API
- Functions to Reversible computing
- Functions to CMOS
- Fuctions to Integral Circuit 

## Representation of binary.
| Syntax               |   Description     |                       Details                         |
| :---                 |      :----:       |                                                  ---: |
| 1	0	1	0	0	1	1	0	1	1  |  (1 = +, 0 = -)   | (1 = have electric current, 0 = no electric current)  |
| ‚òí	‚òê	‚òí	‚òê	‚òê	‚òí	‚òí	‚òê	‚òí	‚òí  |  (‚òí = +, ‚òê = -)   | (‚òí = have electric current, ‚òê = no electric current)  |
| y	n	y	n	n	y	y	n	y	y  |  (y = +, n = -)   | (y = have electric current, n = no electric current)  |

### Cicada 3301.

- Please solve the infinitive puzzle... (Serbian: Beli zec je potra≈æio utoƒçi≈°te u jednoj pokrajini u centru Srbije jer je bio progonjen od strane blizanaca. Priƒça se da je beli zec sa sobom poneo beskonaƒçnu svesku i beskonaƒçnu olovku da upisuje svaki fajl u taj pribor. Beli zec je prona≈°ao naƒçin kako da putem teorije Maksvelovog demona uspe da razre≈°i misteriju reversibilnih procesa. Shvatio je da teorija Maksvelovog demona prkosi svim zakonima termodinamike i na taj naƒçin sebi obezbedio makar poku≈°aj sa beskonaƒçnom sveskom i olovkom koja ne prestaje da radi. Ukoliko beli zec pronaƒëe sledeƒáu zagonetku cicade 3301 to bi znaƒçilo da je jedan zadatak re≈°en i da bi sve ≈°to je moguƒáe dekriptovati smestiti u jednu kofu gde bi se proces vratio u nazad.)
- Down the rabbit hole.
- Please follow instructions.
- Please be gentle to my code.

<p align="left">
  <img src="https://github.com/antistereotip/ghost/blob/main/SOCIETY/puzzle.gif" width="300" />
</p>

- Follow the white rabbit.
- Alice in wonderland.

<p align="left">
  <img src="https://github.com/antistereotip/ghost/blob/main/SOCIETY/rabbit.jpg" width="300" />
</p>

## Development.

- Development have 2 segments: Socket I/O, Low/High Level Applications.
- Please contribute to this project and go deep into Socket Programming and Low/High Level Programming.
- Ghost represented in web will be in frames of engine up-a: https://github.com/antistereotip/ng1np and Null project https://github.com/antistereotip/NULL

### Our way or the highway
<pre>
//GHOST
gates.gpfs
----------
XOR->NOR->NAND
4 8 12 16 20 24 28 32
32 28 24 20 16 12 8 4
NAND->NOR->XOR
32 28 24 20 16 12 8 4
4 8 12 16 20 24 28 32
</pre>

### Examples of starting apps:
<pre>
//GHOST
null.gpfs
---------
run(ghost.gpfs) - [parameters: initial, start, bootloader]
run(app.store) - [parameters: store, buy, sell, load]
run(buy.eth) - [parameters: store, buy, crypto, load]
run(sell.btc) - [parameters: store, sell, crypto, load]
run(gta5.game) - [parameters: gta5 game, streaming, load.graphic, load]
</pre>

#### Abstraction of coding.
<pre>
//GHOST 
app.gpfs
--------
Super easy and logical syntax
--------
run(store, game, sell.btc, buy.eth, game.gta5)
</pre>
<pre>
//GHOST 
linear_regression.gpfs
----------------------
X = run('app', [-20, 60])
Y = run('app.store', 1.5)
f(x) = 3*x/20 + 5
random = [X.get_random_element() for _ in range(1337)]
data = [(x, f(x) + Y.get_random_element()) for x in random]
m, b = var('m b')
run(x) = m*x + b
run(x) = g(x).subs(find_fit(data, g, solution_dict=True))
p = run(data) + plot(g, (x, -20, 60), color='red')
p.save('linear_regression.gpfs')
run(app.gpfs)
run(null.gpfs)
</pre>
Source: https://github.com/antistereotip/NULL

Pravljenje internet protokola je zapravo kombinacija teorije (definisanje pravila komunikacije) i prakse (implementacija tih pravila u kodu).
Ako hoƒáe≈°, mogu ti objasniti proces od nule do gotovog protokola, korak po korak.

1Ô∏è‚É£ Razumevanje ≈°ta je protokol

Internet protokol je skup pravila koja defini≈°u:

Kako se ureƒëaji meƒëusobno povezuju.

Kako se formatiraju i ≈°alju podaci.

Kako se proverava da li su podaci stigli ispravno.

Primeri: HTTP, FTP, SMTP, TCP, UDP.

2Ô∏è‚É£ Odabir sloja u mre≈ænom modelu

Protokol se obiƒçno uklapa u OSI model ili TCP/IP model.

Fiziƒçki / Data link sloj ‚Äì Pravila za kablove, signale, MAC adrese.

Mre≈æni sloj ‚Äì Ruting paketa (npr. IP).

Transportni sloj ‚Äì Kontrola prenosa i gre≈°aka (npr. TCP, UDP).

Aplikativni sloj ‚Äì Pravila aplikacija (npr. HTTP, DNS).

üí° Veƒáina custom protokola se pravi na aplikativnom sloju, jer se oslanja na postojeƒáe TCP/UDP/IP slojeve.

3Ô∏è‚É£ Definisanje formata poruke

Mora≈° odrediti:

Zaglavlje (header) ‚Äì Meta podaci (tip poruke, du≈æina, checksum‚Ä¶)

Telo (payload) ‚Äì Stvarni podaci.

Kodiranje ‚Äì Tekst (UTF-8), binarno, JSON, XML‚Ä¶

Primer jednostavnog formata:

[4 bajta] ‚Äì tip poruke
[4 bajta] ‚Äì veliƒçina
[x bajtova] ‚Äì podaci

4Ô∏è‚É£ Pravila komunikacije (state machine)

Mora≈° odrediti:

Ko zapoƒçinje vezu (klijent ili server).

Kako izgleda handshake (npr. pozdravna poruka).

Kako se odgovara na zahteve.

≈†ta se radi kad doƒëe do gre≈°ke.

5Ô∏è‚É£ Implementacija

Izaberi transport (TCP ili UDP).

Napi≈°i kod koji ≈°alje i prima poruke po definisanom formatu.

Testiraj na dve ma≈°ine ili u virtuelnoj mre≈æi.

Primer mini protokola preko TCP-a u Python-u (aplikativni sloj):

# server.py
import socket

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind(("0.0.0.0", 5000))
server.listen(1)

print("Server ƒçeka konekciju...")
conn, addr = server.accept()
print(f"Povezano sa {addr}")

while True:
    data = conn.recv(1024)
    if not data:
        break
    print("Primljeno:", data.decode())
    conn.send(b"ACK")  # odgovor

# client.py
import socket

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect(("127.0.0.1", 5000))

client.send(b"HELLO")
print("Odgovor servera:", client.recv(1024))

6Ô∏è‚É£ Dokumentacija (specifikacija)

Pravi protokoli (npr. HTTP/2, QUIC) imaju RFC dokument sa:

Detaljnim formatom poruka.

Sekvencama komunikacije.

Primerima.

7Ô∏è‚É£ Standardizacija (opciono)

Ako ≈æeli≈° da protokol postane javni standard:

Predla≈æe se IETF-u ili drugom telu.

Dobija svoj RFC broj.

Ako ≈æeli≈°, mogu ti napraviti primer potpuno novog internet protokola sa izmi≈°ljenim pravilima i formatom, i pokazati kako bi radio u praksi.
To bi bio ba≈° realistiƒçan mini-RFC.

–ö–∞–∂–µ—à:
moze
ChatGPT —ò–µ —Ä–µ–∫–∞–æ:

Evo ti primer od nule kako bih napravio jedan izmi≈°ljeni internet protokol ‚Äî pokazaƒáu ti ga kao pravi mini-RFC, sa formatom poruka, pravilima komunikacije i kodom.

üìú RFC-DRAFT: SimpleChat Protocol (SCP)
1Ô∏è‚É£ Opis

SCP (SimpleChat Protocol) je jednostavan aplikativni protokol za razmenu tekstualnih poruka izmeƒëu klijenta i servera preko TCP-a.
Cilj je brz tekstualni chat sa minimalnim zaglavljima.

2Ô∏è‚É£ Transport

Transportni sloj: TCP

Port: 5050 (podrazumevani)

3Ô∏è‚É£ Format poruke

Svaka poruka ima binarni format:

Polje	Veliƒçina	Opis
Version	1 bajt	Verzija protokola (npr. 1)
Type	1 bajt	Tip poruke (1=MSG, 2=PING, 3=PONG, 4=BYE)
Length	2 bajta	Du≈æina payload-a u bajtovima (big endian)
Payload	N bajtova	Tekstualni sadr≈æaj (UTF-8)
4Ô∏è‚É£ Pravila komunikacije

Handshake ‚Äì Klijent ≈°alje PING, server vraƒáa PONG.

Razmena poruka ‚Äì Klijent i server ≈°alju MSG tip sa tekstom.

Zatvaranje veze ‚Äì Klijent ili server ≈°alju BYE.

5Ô∏è‚É£ Primer poruke

Poruka ‚ÄûZdravo‚Äú (MSG tip) u binarnom obliku:

Version: 1         -> 0x01
Type: MSG (1)      -> 0x01
Length: 6          -> 0x0006
Payload: "Zdravo"  -> 0x5A 0x64 0x72 0x61 0x76 0x6F


Cela poruka u hex:

01 01 00 06 5A 64 72 61 76 6F

6Ô∏è‚É£ Minimalna implementacija

server.py

import socket, struct

def send_message(conn, mtype, payload):
    payload_bytes = payload.encode('utf-8')
    header = struct.pack("!BBH", 1, mtype, len(payload_bytes))
    conn.sendall(header + payload_bytes)

def recv_message(conn):
    header = conn.recv(4)
    if not header: return None, None
    version, mtype, length = struct.unpack("!BBH", header)
    payload = conn.recv(length).decode('utf-8')
    return mtype, payload

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind(("0.0.0.0", 5050))
server.listen(1)
print("SCP Server listening...")

conn, addr = server.accept()
print(f"Connected by {addr}")

# Handshake
mtype, payload = recv_message(conn)
if mtype == 2:  # PING
    send_message(conn, 3, "PONG")

# Chat loop
while True:
    mtype, payload = recv_message(conn)
    if mtype == 4:  # BYE
        break
    print(f"Client: {payload}")
    send_message(conn, 1, f"Eho: {payload}")

conn.close()


client.py

import socket, struct

def send_message(sock, mtype, payload):
    payload_bytes = payload.encode('utf-8')
    header = struct.pack("!BBH", 1, mtype, len(payload_bytes))
    sock.sendall(header + payload_bytes)

def recv_message(sock):
    header = sock.recv(4)
    if not header: return None, None
    version, mtype, length = struct.unpack("!BBH", header)
    payload = sock.recv(length).decode('utf-8')
    return mtype, payload

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(("127.0.0.1", 5050))

# Handshake
send_message(sock, 2, "PING")
mtype, payload = recv_message(sock)
print("Handshake:", payload)

# Chat
while True:
    text = input("Ti: ")
    send_message(sock, 1, text)
    mtype, payload = recv_message(sock)
    print("Server:", payload)
    if text.lower() == "bye":
        send_message(sock, 4, "")
        break

sock.close()

7Ô∏è‚É£ Karakteristike

Prednost: Lako parsiranje (uvek 4 bajta zaglavlja, pa payload).

Nedostatak: Nema enkripciju, nema autentikaciju.

Moguƒáe pro≈°irenje: Dodavanje enkripcije (TLS) ili vi≈°e tipova poruka.

Ako hoƒáe≈°, mogu ti napraviti napredniju verziju ovog protokola koja ima autentikaciju i enkripciju poput HTTPS-a, ali jednostavnije.
To bi veƒá bilo ozbiljnije, ali i dalje ruƒçno razumljivo.

–ö–∞–∂–µ—à:
moze
ChatGPT —ò–µ —Ä–µ–∫–∞–æ:
–†–∞–∑–º–∏—à—ô–∞–æ —Å–∞–º 27s

Super ‚Äî idemo na napredniju varijantu sa TLS enkripcijom i token autentikacijom. Dobiƒáe≈° mini-RFC i radan primer klijent/server koda u Pythonu.

üìú RFC-DRAFT: Secure SimpleChat Protocol (SCP/2)
1) Cilj

SCP/2 je aplikativni protokol za chat preko TCP + TLS 1.3.
Funkcije:

End-to-end enkripcija kanala (TLS).

Login sa korisniƒçkim imenom/lozinkom (unutar TLS).

Kratko≈æiveƒái HMAC token za svaku narednu poruku.

Jednostavno binarno uokviravanje (framing).

2) Transport

Sloj: TCP, obavezno TLS.

Port (default): 5443.

Verzija protokola: 2.

3) Tipovi poruka (Type)
1=AUTH_REQ     (klijent ‚Üí server)  JSON: {"username","password"}
2=AUTH_OK      (server ‚Üí klijent)  JSON: {"token","exp"}
3=AUTH_FAIL    (server ‚Üí klijent)  JSON: {"error"}
4=MSG          (obe strane)        payload = UTF-8 tekst
5=PING         (obe strane)        payload = ""
6=PONG         (obe strane)        payload = ""
7=BYE          (obe strane)        payload = ""
8=ERROR        (server ‚Üí klijent)  JSON: {"error"}

4) Okvir (framing) ‚Äî header + telo

Header (8 bajtova, big-endian / network order):

[1B] Version      (uvek 0x02)
[1B] Type         (vidi gore)
[2B] TokenLen     (0..65535)
[4B] PayloadLen   (0..4,294,967,295)


Body:

[TokenLen bajtova]  Token (ASCII/base64url); 0 ako nije potreban (AUTH_REQ, PING/PONG poƒçetni)
[PayloadLen bajtova] Payload (UTF-8 ili binarno po tipu)


Token obavezan za sve poruke posle uspe≈°nog logina (MSG/PING/PONG/itd.).
Server odbija poruke sa neva≈æeƒáim ili isteklim tokenom (8=ERROR).

5) Tok komunikacije (state machine)

TLS handshake (kanal je ≈°ifrovan).

Klijent ≈°alje AUTH_REQ (tokenlen=0) sa JSON kredencijalima u payload-u.

Server vraƒáa AUTH_OK (tokenlen=0) sa JSON-om: {"token":"‚Ä¶","exp": unix_ts}
‚Äì Token je HMAC-SHA256 potpis: base64url(HMAC(server_secret, username|exp|random)).
‚Äì Tipiƒçan TTL: 10 min.

Sve naredne poruke (npr. MSG) nose token u polju Token.

Zatvaranje: bilo ko ≈°alje BYE.

6) Bezbednosne napomene

TLS veƒá obezbeƒëuje poverljivost i integritet; token slu≈æi za autorizaciju na aplikativnom sloju (kratko≈æiveƒái, bez ponovnog slanja lozinke).

Za produkciju koristi BCrypt/Argon2 za lozinke i validan CA cert. U primeru ispod, radi jednostavnosti, lozinka je u memoriji, a koristi se samopotpisani sertifikat.

üîê Sertifikati (lokalno, jednokratno)

Kreiraj samopotpisani sertifikat (za test):

openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 -nodes -subj "/CN=localhost"


To ƒáe napraviti cert.pem (javni) i key.pem (privatni). Dr≈æi ih pored skripti.

üß© Implementacija (Python 3.10+)
Zajedniƒçke pomoƒáne funkcije (scp2_common.py)
import struct, json, hmac, hashlib, base64, time

VERSION = 2

# Header: !BBHI  -> Version(1B), Type(1B), TokenLen(2B), PayloadLen(4B) = 8 bajtova
HDR_FMT = "!BBHI"
HDR_SIZE = struct.calcsize(HDR_FMT)

def b64url(b: bytes) -> str:
    return base64.urlsafe_b64encode(b).rstrip(b"=").decode("ascii")

def read_exact(sock, n: int) -> bytes:
    buf = b""
    while len(buf) < n:
        chunk = sock.recv(n - len(buf))
        if not chunk:
            raise ConnectionError("socket closed")
        buf += chunk
    return buf

def send_frame(sock, mtype: int, token: bytes, payload: bytes):
    token = token or b""
    header = struct.pack(HDR_FMT, VERSION, mtype, len(token), len(payload))
    sock.sendall(header + token + payload)

def recv_frame(sock):
    header = read_exact(sock, HDR_SIZE)
    ver, mtype, tlen, plen = struct.unpack(HDR_FMT, header)
    if ver != VERSION:
        raise ValueError(f"Bad version: {ver}")
    token = read_exact(sock, tlen) if tlen else b""
    payload = read_exact(sock, plen) if plen else b""
    return mtype, token, payload

def now() -> int:
    return int(time.time())

def make_token(secret: bytes, username: str, ttl_sec: int = 600) -> tuple[str,int]:
    exp = now() + ttl_sec
    msg = f"{username}|{exp}|".encode("utf-8") + hashlib.sha256(str(time.time_ns()).encode()).digest()
    sig = hmac.new(secret, msg, hashlib.sha256).digest()
    tok = b64url(msg + sig)
    return tok, exp

def verify_token(secret: bytes, token: str, username: str) -> bool:
    try:
        # pad base64
        pad = "=" * (-len(token) % 4)
        raw = base64.urlsafe_b64decode(token + pad)
        msg, sig = raw[:-32], raw[-32:]
        exp_str = msg.split(b"|")[1].decode()
        exp = int(exp_str)
        if exp < now():
            return False
        calc = hmac.new(secret, msg, hashlib.sha256).digest()
        return hmac.compare_digest(sig, calc) and msg.decode(errors="ignore").startswith(username + "|")
    except Exception:
        return False

Server (scp2_server.py)
import ssl, socket, json, threading
from scp2_common import send_frame, recv_frame, make_token, verify_token, now

HOST, PORT = "0.0.0.0", 5443
SERVER_SECRET = b"super-secret-change-me"

# Demo "baza" korisnika (plaintext radi jednostavnosti demoa!)
USERS = {
    "ana": "lozinka123",
    "marko": "tajna",
}

TYPE = {
    "AUTH_REQ":1, "AUTH_OK":2, "AUTH_FAIL":3, "MSG":4, "PING":5, "PONG":6, "BYE":7, "ERROR":8
}

def handle_client(conn, addr):
    print(f"[+] TLS klijent: {addr}")
    authed_user = None
    token_cache = None

    try:
        while True:
            mtype, token, payload = recv_frame(conn)

            if mtype == TYPE["AUTH_REQ"]:
                data = json.loads(payload.decode("utf-8"))
                u, p = data.get("username"), data.get("password")
                if u in USERS and USERS[u] == p:
                    tok, exp = make_token(SERVER_SECRET, u, ttl_sec=600)
                    token_cache = tok
                    authed_user = u
                    send_frame(conn, TYPE["AUTH_OK"], b"", json.dumps({"token": tok, "exp": exp}).encode())
                else:
                    send_frame(conn, TYPE["AUTH_FAIL"], b"", json.dumps({"error":"Bad credentials"}).encode())

            elif mtype in (TYPE["MSG"], TYPE["PING"], TYPE["PONG"]):
                if not authed_user or not token:
                    send_frame(conn, TYPE["ERROR"], b"", json.dumps({"error":"Auth required"}).encode())
                    continue
                tok_str = token.decode("ascii")
                if not verify_token(SERVER_SECRET, tok_str, authed_user):
                    send_frame(conn, TYPE["ERROR"], b"", json.dumps({"error":"Invalid/expired token"}).encode())
                    continue

                if mtype == TYPE["PING"]:
                    send_frame(conn, TYPE["PONG"], token, b"")
                elif mtype == TYPE["MSG"]:
                    txt = payload.decode("utf-8", errors="replace")
                    print(f"[{authed_user}] {txt}")
                    send_frame(conn, TYPE["MSG"], token, f"Eho: {txt}".encode("utf-8"))

            elif mtype == TYPE["BYE"]:
                break

            else:
                send_frame(conn, TYPE["ERROR"], b"", json.dumps({"error":"Unknown type"}).encode())

    except Exception as e:
        print("[-] Gre≈°ka:", e)
    finally:
        conn.close()
        print(f"[x] Zatvoreno: {addr}")

def main():
    # TLS kontekst (server)
    ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
    ctx.minimum_version = ssl.TLSVersion.TLSv1_3
    ctx.load_cert_chain(certfile="cert.pem", keyfile="key.pem")

    with socket.create_server((HOST, PORT), reuse_port=True) as s:
        with ctx.wrap_socket(s, server_side=True) as tls_srv:
            print(f"[i] SCP/2 server na tls://{HOST}:{PORT}")
            while True:
                conn, addr = tls_srv.accept()
                threading.Thread(target=handle_client, args=(conn, addr), daemon=True).start()

if __name__ == "__main__":
    main()

Klijent (scp2_client.py)
import ssl, socket, json
from scp2_common import send_frame, recv_frame

HOST, PORT = "localhost", 5443

TYPE = {
    "AUTH_REQ":1, "AUTH_OK":2, "AUTH_FAIL":3, "MSG":4, "PING":5, "PONG":6, "BYE":7, "ERROR":8
}

def main():
    # TLS kontekst (klijent)
    ctx = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)
    # DEMO: prihvati samopotpisani sertifikat bez provere hostname-a (za produkciju ‚Äì validan CA!)
    ctx.check_hostname = False
    ctx.verify_mode = ssl.CERT_NONE
    # Ako ≈æeli≈° proveru, umesto CERT_NONE uradi:
    # ctx.load_verify_locations(cafile="cert.pem")
    # ctx.verify_mode = ssl.CERT_REQUIRED
    # ctx.check_hostname = False

    with socket.create_connection((HOST, PORT)) as raw:
        with ctx.wrap_socket(raw, server_hostname=HOST) as sock:
            print("[i] TLS veza uspostavljena")

            # 1) AUTH_REQ
            creds = {"username":"ana", "password":"lozinka123"}
            send_frame(sock, TYPE["AUTH_REQ"], b"", json.dumps(creds).encode())

            mtype, token, payload = recv_frame(sock)
            if mtype != TYPE["AUTH_OK"]:
                print("Autentikacija neuspe≈°na:", payload.decode())
                return
            data = json.loads(payload.decode())
            token_str = data["token"].encode("ascii")
            print("[i] Dobijen token.")

            # 2) Chat
            while True:
                txt = input("Ti: ")
                send_frame(sock, TYPE["MSG"], token_str, txt.encode("utf-8"))
                mtype, _, payload = recv_frame(sock)
                if mtype == TYPE["ERROR"]:
                    print("Gre≈°ka:", payload.decode())
                elif mtype == TYPE["MSG"]:
                    print("Server:", payload.decode())
                if txt.lower() == "bye":
                    send_frame(sock, TYPE["BYE"], token_str, b"")
                    break

if __name__ == "__main__":
    main()

Kako pokrenuti (lokalno)

Napravi sertifikate (jednom):

openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 -nodes -subj "/CN=localhost"


Saƒçuvaj tri fajla u isti folder: scp2_common.py, scp2_server.py, scp2_client.py.

Pokreni server:

python scp2_server.py


U drugom terminalu pokreni klijenta:

python scp2_client.py


Upi≈°i poruke; server vraƒáa ‚ÄúEho: ‚Ä¶‚Äù. Za izlaz po≈°alji bye.

Ideje za dalja unapreƒëenja

Mutual TLS (mTLS) ‚Äì klijent takoƒëe ima sertifikat; server tra≈æi i verifikuje.

Argon2/BCrypt i baza (SQL/NoSQL) za lozinke i korisnike.

Obnova tokena (REFRESH) i rotacija tajne.

Rate-limit i replay protection (nonce + server memorija kratkog roka).

Protobuf/CBOR umesto JSON-a za kompaktnost.

Vi≈°ekorisniƒçke sobe sa broadcast-om i listom ƒçlanova (novi tipi poruka).

## Important documentation links:
### You can not start without reading this documents.
0. https://github.com/antistereotip/ghost
1. https://github.com/antistereotip/ghost/blob/main/README.md
2. https://github.com/antistereotip/ghost/blob/main/GATES/README.md
3. https://github.com/antistereotip/ghost/blob/main/RUN/README.md
4. https://github.com/antistereotip/ghost/blob/main/SOCIETY/README.md
5. https://github.com/antistereotip/ghost/blob/main/ZERO-SQUAD/README.md
6. https://github.com/antistereotip/ghost/blob/main/0/README.md


#### Find the Ghost. Under is fake Ghost Logotip. Be Carefull !!!
<img src="https://github.com/antistereotip/ghost/blob/main/DATA/ghost-icon.png" width="100" />






 
